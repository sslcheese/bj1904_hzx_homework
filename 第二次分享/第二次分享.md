![p](C:\Users\sslcheese\Desktop\第二次分享\p.png)













![p1](C:\Users\sslcheese\Desktop\第二次分享\p1.png)







![迪杰斯特拉算法](C:\Users\sslcheese\Desktop\第二次分享\迪杰斯特拉算法.png)

假如图中有n个顶点，如果不考虑堆优化，一次迪杰斯特拉算法的时间复杂度是O（n^2）。所以，把每一个顶点都计算一遍，总的时间复杂度是O（n^3）。 





弗洛伊德算法

![p3](C:\Users\sslcheese\Desktop\第二次分享\p3.png)

上图的顶点A和顶点C没有直接相连的边，它们之间的直接距离是无穷大。

如果以B作为“中继顶点”，此时A到C的最短路径就是A-B-C，最短距离是3+2=5。



![p4](C:\Users\sslcheese\Desktop\第二次分享\p4.png)

上图的顶点A和顶点C直接相连，距离是6。但是存在一条“迂回”路径A-B-C，距离是3+2=5<6。

所以，经过中继顶点B，从A到C的最短距离可以是5。



下面我们来看一看Floyd算法的详细步骤。 

1.要实现Floyd算法，首先需要构建带权图的邻接矩阵：![p5](C:\Users\sslcheese\Desktop\第二次分享\p5.png)

在邻接矩阵当中，每一个数字代表着从某个顶点到另一个顶点的直接距离，这个距离是没有涉及到任何中继顶点的。



2.此时假定只允许以顶点A作为中继顶点，那么各顶点之间的距离会变成什么样子呢？

B和C之间的距离原本是无穷大，此时以A为中继，距离缩短为AB距离+AC距离=

5+2=7。

更新对应矩阵元素（橙色区域代表顶点A到其他顶点的临时距离）： 

![p6](C:\Users\sslcheese\Desktop\第二次分享\p6.png)



3.接下来以顶点A、B作为中继顶点，那么各顶点之间的距离会变成什么样子呢？

A和D之间的距离原本是无穷大，此时以B为中继，距离缩短为AB距离+BD距离=5+1=6。

A和E之间的距离原本是无穷大，此时以B为中继，距离缩短为AB距离+BE距离=5+6=11。

更新对应矩阵元素（橙色区域代表顶点B到其他顶点的临时距离）： 

![p6](C:\Users\sslcheese\Desktop\第二次分享\p7.png)

4.接下来以顶点A、B、C作为中继顶点，那么各顶点之间的距离会变成什么样子呢？

A和F之间的距离原本是无穷大，此时以C为中继，距离缩短为AC距离+CF距离=2+8=10。

更新对应矩阵元素（橙色区域代表顶点C到其他顶点的临时距离）：

![p6](C:\Users\sslcheese\Desktop\第二次分享\p8.png)



以此类推，我们不断引入新的中继顶点，不断刷新矩阵中的临时距离。

最终，当所有顶点都可以作为中继顶点时，我们的距离矩阵更新如下：

![p6](C:\Users\sslcheese\Desktop\第二次分享\p9.png)

此时，矩阵中每一个元素，都对应着某顶点到另一个顶点的最短距离。 





让我们回顾一下动态规划的两大要素：

***问题的初始状态***
***问题的状态转移方程式***



对于寻找图的所有顶点之间距离的问题，初始状态就是顶点之间的直接距离，也就是邻接矩阵。



而问题的状态转移方程式又是什么呢？

假设新引入的中继顶点是n，那么：



**顶点i 到 顶点j 的新距离 = Min（顶点i 到 顶点j 的旧距离，顶点i 到 顶点n 的距离+顶点n 到 顶点j 的距离）**





 

